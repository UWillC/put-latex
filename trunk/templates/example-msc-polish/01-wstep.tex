\chapter{Wprowadzenie}

% [DW] Cytowania normalnie, bez dodatkowych nawiasów; poprawiłem niektóre, zrób pozostałe.

Drzewa sufiksów oraz tablice sufiksów, czyli tablice leksykograficznie posortowanych sufiksów pewnego
ciągu symboli, znajdują wiele praktycznych zastosowań:

\begin{itemize}
    \item w~problemach przetwarzania tekstu, nazywanych żargonowo~\emph{stringology}, takich
    jak dopasowywanie, przeszukiwanie, wyszukiwanie powtarzających się podciągów 
    i~maksymalnych sekwencji~\cite{Manber90, gusfield} oraz
    wielu innych;

    \item w~bioinformatyce~\cite{abouelhoda-genome}, gdzie
    pytania dotyczące kodu genetycznego można sprowadzić do rozwiązania problemów operujących 
    na ciągach znaków;

    \item w~kompresji danych~\cite{BW}, gdzie wykorzystywane są do wyszukiwania powtarzających
    się sekwencji symboli i do obliczania transformacji Burrowsa-Wheelera 
    (\english{Burrows-Wheeler transform}, \akronim{BWT}), która jest krokiem wstępnym
    takich metod kompresji danych, jak np.~\texttt{bzip2}.
\end{itemize}

Większość z~powyższych problemów daje się efektywnie rozwiązać przy pomocy 
drzew sufiksów (\english{suffix tree}). Udowodniono jednakże~\cite{replacing},
że tablice sufiksów są w~wielu przypadkach równie dobrą strukturą danych co drzewa sufiksów, 
a~ponieważ ich konstrukcja jest zwykle obarczona
mniejszym kosztem pamięciowym i~czasowym (mimo tej samej teoretycznej
złożoności $\bigO(n)$), to właśnie tablice sufiksów cieszą się coraz większym
powodzeniem w~praktyce.

Istnieje wiele algorytmów tworzenia tablic sufiksów, w~większości opublikowanych wraz z~implementacjami
w~języku \texttt{C} lub \texttt{C++}. O~ile od strony teoretycznej
większość z~tych algorytmów jest efektywna (liniowa), o~tyle w~praktyce ich efektywność zależy od aspektów
dostępu do pamięci oraz wielkości słownika symboli. Brakuje również
implementacji tych algorytmów w~językach wysokiego poziomu, takich jak język Java. 
Tym brakiem właśnie motywujemy potrzebę opracowania w~języku Java biblioteki algorytmów tworzenia 
tablic sufiksów. Przeniesienie samych algorytmów do języka Java wymaga zwrócenia szczególnej uwagi na
jego cechy specyficzne w~stosunku do języków niskiego poziomu -- różnice w~dostępie do pamięci 
(brak wskaźników, relokowalne struktury danych), zarządzanie pamięcią przez maszynę
wirtualną (\emph{garbage collector}), czy też fakt, że kod programu poddawany jest bezustannej obserwacji
i~kompilacji w~czasie rzeczywistym (\emph{just in time compilation}).


\section{Cel i~zakres pracy}

Głównym celem tej pracy jest \textbf{wybór najlepszych algorytmów tworzenia tablic sufiksów oraz
ich  efektywna implementacja w~postaci biblioteki  napisanej w~języku Java}.  W~zakres pracy wliczony jest również przegląd obecnie dostępnej literatury poświęconej  metodom
tworzenia tablic sufiksów oraz opis najciekawszych spośród nich. Docelowo powinna powstać
więc pewna taksonomia opierająca się na schemacie działania algorytmów i~umożliwiająca ich porównanie i~odniesienie względem siebie. 

Drugim celem pracy jest dokładne przetestowanie i~analiza utworzonej implementacji i~określenie jej wydajności na różnych
maszynach wirtualnych oraz na różnych platformach sprzętowych. Uzyskane wyniki eksperymentalne
skonfrontowane zostaną z~istniejącymi wynikami testów wydajnościowych implementacji tych
samych algorytmów w~językach \texttt{C} i~\texttt{C++}. 

\section{Struktura pracy}

W~rozdziałach drugim i~trzecim przedstawiono przegląd literatury dziedzinowej; rozdział drugi
zawiera podstawy teoretyczne wprowadzające czytelnika w~tematykę tablic sufiksów, a~trzeci
poświęcony jest klasyfikacji i~przeglądowi metod tworzenia tablic sufiksów. Rozdział czwarty zawiera
opisy wybranych algorytmów. W rozdziale piątym podane są wyniki empirycznych testów 
wydajnościowych wykonanych w różnych środowiskach i na różnych maszynach wirtualnych. 
Rozdział szósty stanowi podsumowanie pracy.

